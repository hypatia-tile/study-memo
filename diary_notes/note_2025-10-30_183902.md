# 2025-10-30_183902

This is a temporary note for my daily learning.
Contents will be moved to other places later.

## Structural type system

It contrasts with nominative systems, where comparisons are based on the names of the types or explicit declarations,
and duck typing, in which only the part of the structure accessed at runtime is checked for compatibility.

```
[
  {0: or["a structural type system", "property-based type system"]},
  {1: "a major class of type systems"},
  {2: "type"},
  {3: "structural type system"},
]
[0].is[1].where(and["compatibility", "equivalence"].of[2']
  .are(determined[
    by: [and["actual structure", "definition"].of[2]],
    not_by: "other characteristics".such_as(their[2'](or["name", "place"]).of("declaration"))
  ]));
[3'].are_used_to_determine(and[
  whether["types are equivalent"],
  whether["a type is a subtype of another"]);
[0].contrasts_with(and[
  "nominative type systems".where(
    "comparisons".are_based_on("the names of the types or explicit declarations")),
  "duck typing".where(
    "only the part of the structure accessed at runtime is checked for compatibility")
]);
```


Description:


```
[
{0: "structural typing"},
{1: "element" },
{2: "feature" },
{2: "type" },
]

[1].is_considered(compatible_with(another([1]))
  .if(
    exists(and[corresponding,identical]([2]))
    .in([3].of("first element"))
    .for_each([3].within([2].of("the second element")))))
  .in[0]
some("language'")
  .may(differ().on_the_ditails().such_as(whether([2].must(mutch().in_name()))))
```


This definition is not symmetric, and includes subtype compatibility.
Two types are considered to be identical if each is compatible with the other.
