# z-buffering in C

[source, c]
----
#include <stdio.h>
#include <stdlib.h>
#include <float.h>
#include <math.h>

#define WIDTH 800
#define HEIGHT 600

typedef struct {
    unsigned char r, g, b;
} Color;

float z_buffer[HEIGHT][WIDTH];
Color framebuffer[HEIGHT][WIDTH];

void clear_buffers() {
    for (int y = 0; y < HEIGHT; y++)
        for (int x = 0; x < WIDTH; x++) {
            z_buffer[y][x] = INFINITY;
            framebuffer[y][x] = (Color) {0,0,0}; // Black
        }
}

void draw_pixel(int x, int y, float z, Color color) {
    if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT)
        return;

    if (z < z_buffer[y][x]) {
        z_buffer[y][x] = z;
        framebuffer[y][x] = color;
    }
}

// Example of drawing a flat-colored rectangle with depth
void draw_rect_with_depth(int x0, int y0, int x1, int y1, float z, Color color) {
    for (int y = y0; y <= y1; y++)
        for (int x = x0; x <= x1; x++)
            draw_pixel(x, y, z, color);
}

void save_framebuffer_to_ppm(const char* filename) {
    FILE* f = fopen(filename, "wb");
    fprintf(f, "P6\n%d %d\n255\n", WIDTH, HEIGHT);
    for (int y = 0; y < HEIGHT; ++y)
        for (int x = 0; x < WIDTH; ++x)
            fwrite(&framebuffer[y][x], sizeof(Color), 1, f);
    fclose(f);
}

int main() {
    clear_buffers();

    // Closer rectangle
    draw_rect_with_depth(100, 100, 300, 300, 0.5f, (Color){255, 0, 0});

    // Farther rectangle (should be hidden by red one
    draw_rect_with_depth(150, 150, 350, 350, 0.6f, (Color){0, 255, 0});

    save_framebuffer_to_ppm("zbuffer_output2.ppm");

    return 0;
}

----

.Write a PPM
[source, c]
----
fprintf(f, "P6\n%d %d\n255\n", WIDTH, HEIGHT);
----

This code is a standard format string for writing a PPM (Portable Pixmap) image header.
It outputs the PPM magic number (P6),
image dimaensions, and maximum color value in the required format for a binary PPM file.
This format string is part of the `save_framebuffer_to_ppm` function that saves the rendered image to disk.

The overall file appears to be a basic 3D graphics rendering system implementation with z-buffer for handling depth.
It include functionality for managing a framebuffer, z-buffer for depth testing, and basic drawing operations.

The code implements a simple software rasterizer with depth testing capabilities, written in C.
It provides core functionality for pixel manipulation and image output,
supporting basic 3D rendering operations.

.rendering
[source, c]
----
void save_framebuffer_to_ppm(const char* filename) {
    FILE* f = fopen(filename, "wb");
    fprintf(f, "P6\n%d %d\n255\n", WIDTH, HEIGHT);
    for (int y = 0; y < HEIGHT; ++y)
        for (int x = 0; x < WIDTH; ++x)
            fwrite(&framebuffer[y][x], sizeof(Color), 1, f);
    fclose(f);
}
----

This function is responsible for saving the rendered image data from the `framebuffer` into a PPM format file.
It writes the image in binary P6 PPM format,
which includes a header with image specifications followed by the raw RGB color data for each pixel.
The function handles the complete process of opening the file,
writing the header information, saving the pixel data, and properly closing the file.

== P6 PPM Format

The P6 PPM (Portable Pixmap) format is a binary image format
that's part of the broader Netpbm family of image formats.
Here's a concise explanation:

. Structure:
** A text header containing:
*** Magic number `"P6"` (identifies binary RGB format)
*** Width and height in ASCII
*** Maximum color value (typically 255)
*** A single newline character
** Raw binary RGB data following the header
. Key characteristics:
** Binary format (more compact than text-based P3 PPM)
** Each pixel is represented by 3 bytes (R, G, B)
** No compression
** No compression
** Simple and unencrypted
** Very easy to read and write programmatically

PPM format is often used in educational contexts and basic graphics programming due to its simplicity,
though it's not commonly used in productin due to its lack of compression and larger file sizes compared to formats like `PNG` or `JPEG`.

The format's simplicity makes it an excellent choice for learning graphics programming or as an intermediate format for testing image processing algorithms.



